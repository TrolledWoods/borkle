#no_base:

const QueryPerformanceFrequency = fn #call .C: (frequency: &u64) -> i32  extern "QueryPerformanceFrequency";
const QueryPerformanceCounter   = fn #call .C: (frequency: &u64) -> i32  extern "QueryPerformanceCounter";

const MessageBox = fn #call .C: (hwnd: &u8, message: &u8, title: &u8, u_type: u32) -> i32  extern "MessageBoxA";
const OutputDebugString = fn #call .C: (message: &u8) -> ()  extern "OutputDebugStringA";
const WriteConsole = fn #call .C: (console_handle: &u8, buffer: &u8, num_chars: u32, written: &u32, _: &u8) -> i32  extern "WriteConsoleA";
const GetStdHandle = fn #call .C: (handle: u32) -> &u8  extern "GetStdHandle";
const GetLastError = fn #call .C: () -> u32  extern "GetLastError";
const STD_ERROR_HANDLE = 4294967284 : u32;
const STD_OUTPUT_HANDLE = 4294967285 : u32;
const ExitProcess = fn #call .C: (exit_code: u32) -> ()  extern "ExitProcess";

// @Cleanup: We cannot put an invalid pointer into a constant yet, so this is all we can do.
// Later, I might add more control over pointers, so you can store an incorrect into a pointer too,
// or maybe mark it as something that shouldn't be put into the constant table?
const is_invalid_handle_value = fn #call .C: (handle: &u8) -> bool {
    bit_cast handle : isize == -1
};

const VirtualAlloc = fn #call .C: (
    address: &u8,
    size: usize,
    allocation_type: u32,
    protection: u32
) -> &u8
extern "VirtualAlloc";

const VirtualFree = fn #call .C: (address: &u8, size: usize, free_type: u32) -> i32 extern "VirtualFree";

const MEM_COMMIT   = 0x00001000 : u32;
const MEM_DECOMMIT = 0x00004000 : u32;

const PAGE_READWRITE = 0x04 : u32;

const GENERIC_READ  = 0x80000000 : u32;
const GENERIC_WRITE = 0x40000000 : u32;

const CreateConsoleScreenBuffer = fn #call .C: (
    desired_access: u32,
    share_mode: u32,
    security_attributes: &u8,
    flags: u32,
    screen_buffer_data: &u8,
) -> &u8
extern "CreateConsoleScreenBuffer";

const SetConsoleActiveScreenBuffer = fn #call .C: (
    console_output: &u8,
) -> i32
extern "SetConsoleActiveScreenBuffer";

const WriteConsoleOutputCharacter = fn #call .C: (
    console_output: &u8,
    character: &u8,
    length: u32,
    write_coord: (i16, i16),
    written: &u32,
) -> i32
extern "WriteConsoleOutputCharacterA";

const GetAsyncKeyState = fn #call .C: (
    key: i32,
) -> u16
extern "GetAsyncKeyState";

const Sleep = fn #call .C: (millis: u32) -> ()  extern "Sleep";

const CS_VREDRAW = 0x0001 : u16;
const CS_HREDRAW = 0x0002 : u16;
const CS_OWNDC   = 0x0020 : u16;

const WM_ACTIVATEAPP = 0x001C : u32;
const WM_CLOSE        = 0x0010 : u32;
const WM_DESTROY      = 0x0002 : u32;
const WM_SIZE         = 0x0005 : u32;

const WS_OVERLAPPED_WINDOW = 0x00C00000 | 0x00080000 | 0x00040000 | 0x00020000 | 0x00010000 : i32;
const WS_VISIBLE = 0x10000000 : i32;

const CW_USEDEFAULT = -1 : i32;

type HWND = HANDLE;
type HANDLE = &u8;
type HICON  = &u8;
type HBRUSH = HANDLE;
type LPCSTR = &u8;
type HCURSOR = HICON;
type LONG_PTR = usize;
type UINT_PTR = usize;
type LRESULT = LONG_PTR;
type WPARAM = UINT_PTR;
type LPARAM = LONG_PTR;
type ATOM = u16;
type HINSTANCE = HANDLE;
type HMENU = HANDLE;
type LPVOID = &u8;

type WNDCLASS = {
    style: u32;
    lpfnWndProc: WNDPROC;
    cbClsExtra: i32;
    cbWndExtra: i32;
    hInstance: HANDLE;
    hIcon: HICON;
    hCursor: HCURSOR;
    hbrBackground: HBRUSH;
    lpszMenuName: LPCSTR;
    lpszClassName: LPCSTR;
};

const RegisterClass = fn #call .C: (class: &WNDCLASS) -> ATOM  extern "RegisterClassA";

type WNDPROC = fn #call .C: (HWND, u32, WPARAM, LPARAM) -> LRESULT;
const DefWindowProc = fn #call .C: (hwnd: HWND, message: u32, w_param: WPARAM, l_param: LPARAM) -> LRESULT  extern "DefWindowProcA";

const GetModuleHandle = fn #call .C: (handle: LPCSTR) -> HANDLE extern "GetModuleHandleA";

const CreateWindowEx = fn #call .C: (
    dwExStyle: i32,
    lpClassName: LPCSTR,
    lpWindowName: LPCSTR,
    dwStyle: i32,
    X: i32,
    Y: i32,
    nWidth: i32,
    nHeight: i32,
    hWndParent: HWND,
    hMenu: HMENU,
    hInstance: HINSTANCE,
    lpParam: LPVOID,
) -> HWND
extern "CreateWindowExA";

