library "io.bo";
library "slice.bo";

const FormatSpec = type [16] u64;

const Format = type {
    data: FormatSpec,
    print_it: fn(FormatSpec),
};

const ARGUMENT_SPECIFIER = *"%".ptr;

const print = fn(
    fmt_string: [] u8,
    fmt_args = const &[] : [] Format,
) {
    let prev_section = 0 : usize;
    let i = 0 : usize;
    let arg_i = 0 : usize;
    while i < fmt_string.len {
        if *(fmt_string.ptr + i) == ARGUMENT_SPECIFIER {
            put_string(slice_u8(fmt_string, prev_section, i));

            if arg_i >= fmt_args.len {
                put_string("\n\n ---- printf formatting error! There are not enough given formatting arguments!!! ---- \n");
            };

            let format = *(fmt_args.ptr + arg_i);
            (format.print_it)(format.data);

            arg_i = arg_i + 1;

            prev_section = i + 1;
        };
        
        i = i + 1;
    };

    if arg_i != fmt_args.len {
        put_string("\n\n ---- printf formatting error! There number of formatting arguments does not match the number in the string\n");
    };

    put_string(slice_u8(fmt_string, prev_section, i));
};

const fmt_str = fn(string: [] u8) -> Format {
    let format = #uninit : Format;
    *bit_cast &format.data : [] u8 = string;
    format.print_it = fn(data: FormatSpec)  put_string(*bit_cast &data);
    format
};

const dbg_str = fn(string: [] u8) -> Format {
    let format = #uninit : Format;
    *bit_cast &format.data : [] u8 = string;
    format.print_it = fn(data: FormatSpec) {
        put_string("\"");
        put_string(*bit_cast &data);
        put_string("\"");
    };
    format
};

const FormatNumber = type {
    number: u64,
    width: usize,
    pad: u8,
    pad_char: u8,
    is_negative: bool,
};

const internal_fmt_number = fn(data: FormatNumber) -> Format {
    let format = #uninit : Format;
    *bit_cast &format.data : FormatNumber = data;
    format.print_it = fn (arg: FormatSpec) {
        let data = *bit_cast &arg : FormatNumber;

        let ctr = data.number;
        let digits = 0 : usize;
        while ctr > 0 {
            ctr = ctr / 10;
            digits = digits + 1;
        };

        if data.is_negative { digits = digits + 1 };

        if digits < data.width {
            let needed_pad = data.width - digits;
            let needed_right_pad = if data.pad == PAD_RIGHT {
                needed_pad
            } else if data.pad == PAD_CENTER {
                needed_pad / 2
            } else {
                0
            };
            let needed_left_pad = if data.pad == PAD_LEFT {
                needed_pad
            } else if data.pad == PAD_CENTER {
                needed_pad - needed_right_pad
            } else {
                0
            };

            let i = 0 : usize;
            while i < needed_left_pad {
                put_string(<< &[data.pad_char]);
                i = i + 1;
            };

            if data.is_negative {
                put_string("-");
            };
            print_u64(data.number);

            i = 0;
            while i < needed_right_pad {
                put_string(<< &[data.pad_char]);
                i = i + 1;
            };
        } else {
            if data.is_negative { put_string("-"); };
            print_u64(data.number);
        };
    };
    format
};

const PAD_LEFT = 0 : u8;
const PAD_CENTER = 1 : u8;
const PAD_RIGHT = 2 : u8;

const fmt_usize = fn(
    number: usize,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    fmt_u64(number = bit_cast number, width = width, pad = pad, pad_char = pad_char)
};

const fmt_u64 = fn(
    number: u64,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    format.is_negative = bit_cast (0 : u8);
    internal_fmt_number(format)
};

const fmt_u32 = fn(
    number: u32,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    *bit_cast &format.number : u32 = number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    format.is_negative = bit_cast (0 : u8);
    internal_fmt_number(format)
};

const fmt_u16 = fn(
    number: u16,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    *bit_cast &format.number : u16 = number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    format.is_negative = bit_cast (0 : u8);
    internal_fmt_number(format)
};

const fmt_u8 = fn(
    number: u8,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    *bit_cast &format.number : u8 = number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    format.is_negative = bit_cast (0 : u8);
    internal_fmt_number(format)
};

const fmt_i64 = fn(
    number: i64,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    format.is_negative = number < 0;
    *bit_cast &format.number : i64 = if number < 0 { -number } else number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    internal_fmt_number(format)
};

const fmt_i32 = fn(
    number: i32,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    format.is_negative = number < 0;
    *bit_cast &format.number : i32 = if number < 0 { -number } else number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    internal_fmt_number(format)
};

const fmt_i16 = fn(
    number: i16,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    format.is_negative = number < 0;
    *bit_cast &format.number : i16 = if number < 0 { -number } else number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    internal_fmt_number(format)
};

const fmt_i8 = fn(
    number: i8,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    format.is_negative = number < 0;
    *bit_cast &format.number : i8 = if number < 0 { -number } else number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    internal_fmt_number(format)
};

const fmt_isize = fn(
    number: isize,
    width = 0 : usize,
    pad = PAD_LEFT,
    pad_char = " " : u8,
) -> Format {
    let format = #uninit : FormatNumber;
    format.number = 0;
    format.is_negative = number < 0;
    *bit_cast &format.number : isize = if number < 0 { -number } else number;
    format.width = width;
    format.pad = pad;
    format.pad_char = pad_char;
    internal_fmt_number(format)
};
