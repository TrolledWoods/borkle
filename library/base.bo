#no_base:
library "intrinsics.bo";
library "vec.bo";
library "iter.bo";

const true = 1 > (0 : u8);
const false = 1 < (0 : u8);

const min.(T) = fn(a: T, b: T) -> T  if a < b  a else b;
const max.(T) = fn(a: T, b: T) -> T  if a > b  a else b;

const assert = i_assert;

const array_ptr   .(N, T) = fn(array: &[N] T) ->   &T    cast array;
const array_to_buf.(N, T) = fn(array: &[N] T) -> [] T    cast array;

const get_line = fn() -> typeof Vec.(u8) {
    vec_from_iter(take_while(stdin(), fn(v) *v != NEW_LINE))
};

const print = fn(string: [] u8) {
    i_stdout_write(string);
    i_stdout_flush();
};

const filled_array.(N, T) = fn(v: T) -> [N] T {
    let arr = #uninit : [N] T;
    for cast &arr : [] T  { *_it = v; };
    arr
};

const copy.(T) = fn(to: &T, from: &T, size: usize) {
    i_copy(cast to, cast from, size * sizeof T);
};

const copy_nonoverlapping.(T) = fn(to: &T, from: &T, size: usize) {
    i_copy_nonoverlapping(cast to, cast from, size * sizeof T);
};

const alloc.(T) = fn(count: usize) -> [] T {
    let buf = #0;
    buf.ptr = cast i_alloc(count * sizeof T);
    buf.len = count;
    buf
};

const dealloc.(T) = fn(buf: [] T) {
    let temp = #0;
    temp.ptr = cast buf.ptr;
    temp.len = buf.len * sizeof T;
    i_dealloc(temp);
};

const fill.(T) = fn(buf: [] T, value: T) {
    for buf { *_it = value; };
};

const slice_cmp.(T) = fn(a: [] T, b: [] T) -> bool { 'function
    if a.len != b.len  break 'function false;

    while _iters < a.len {
        if *(a.ptr + _iters) != *(b.ptr + _iters)  break 'function false;
    };

    true
};

const slice_to_end.(T) = fn(buf: [] T, start: usize) -> [] T {
    slice.(T)(buf, start, buf.len)
};

const slice.(T) = fn(buf: [] T, start: usize, end: usize) -> [] T {
    assert(start < end);
    assert(end <= buf.len);
    let new = #uninit;
    new.ptr = buf.ptr + start;
    new.len = end - start;
    new
};

const count_matches.(T) = fn(buf: [] T, predicate: fn(&T) -> bool) -> usize {
    let count = 0;
    for buf  if predicate(_it)  count = count + 1;
    count
};

const count_ones.(T) = fn(number: T) -> usize {
    let bit = 1;
    let num_bits = 0;
    while _iters < (8 * sizeof T) && bit <= number {
        if (number & bit) > 0  num_bits = num_bits + 1;
        bit = bit << 1;
    };
    num_bits
};

const DIGIT0 = 48 : u8;

// TEMPORARY until not operator is done a gain
const not = fn(v: bool) -> bool  if v false else true;

const cmp_strings = fn(a: [] u8, b: [] u8) -> bool { 'function
    if a.len != b.len  break 'function false;

    for c in a {
        if *c != *(b.ptr + _iters)  break false;
    } else true
};

const put_char = fn(c: u8) {
    let buf = #0;
    buf.ptr = &c;
    buf.len = 1;
    i_stdout_write(buf);
};

const take_char = fn(string: &[] u8) -> u8 {
    let c = *string.ptr;
    advance(string);
    c
};

const advance_by = fn(string: &[] u8, by: usize) {
    assert(string.len >= by);
    string.ptr = string.ptr + by;
    string.len = string.len - by;
};

const advance = fn(string: &[] u8) {
    if string.len > 0 {
        string.ptr = string.ptr + 1;
        string.len = string.len - 1;
    };
};

const empty = fn(string: &[] u8) -> bool   string.len == 0;

const take_u64_with_base = fn(string: &[] u8, base: u64) -> u64 {
    let number = 0;
    while string.len > 0 {
        let c = *string.ptr;
        if not(is_digit(c))  break;
        number = number * base + (cast (c - DIGIT0) : u64);
        advance(string);
    };
    number
};

const take_u64 = fn(string: &[] u8) -> u64 {
    let number = 0;
    while string.len > 0 {
        let c = *string.ptr;
        if not(is_digit(c))  break;
        number = number * 10 + (cast (c - DIGIT0) : u64);
        advance(string);
    };
    number
};

const skip_num = fn(string: &[] u8) -> [] u8 {
    let new = #uninit;
    new.ptr = string.ptr;
    new.len = 0;

    while 'loop string.len > 0 {
        advance(string);
        if not(is_digit(*string.ptr))  break 'loop;
        new.len = new.len + 1;
    };

    new
};


const take_word = fn(string: &[] u8) -> [] u8 {
    let length = 0;
    let start = string.ptr;
    while string.len > 0 {
        if not(
            is_alpha(
                *string.ptr
            )) break;
        length = length + 1;
        advance(string);
    };

    let buf = #0;
    buf.len = length;
    buf.ptr = start;
    buf
};

const take_whitespace = fn(string: &[] u8) {
    while string.len > 0 {
        if not(is_whitespace(*string.ptr)) break;
        advance(string);
    };
};

const SPACE = *" ".ptr;
const NEW_LINE = *"\n".ptr;
const TAB = *"\t".ptr;
const CARRIAGE_RETURN = *"\r".ptr;
const LOWER_A = *"a".ptr;
const LOWER_Z = *"z".ptr;
const UPPER_A = *"A".ptr;
const UPPER_Z = *"Z".ptr;

const is_alpha = fn(c: u8) -> bool {
    (c >= LOWER_A && c <= LOWER_Z) || (c >= UPPER_A && c <= UPPER_Z)
};

const is_whitespace = fn(c: u8) -> bool {
    c == SPACE || c == NEW_LINE || c == TAB || c == CARRIAGE_RETURN
};

const is_digit = fn(c: u8) -> bool {
    c >= DIGIT0 && c < DIGIT0 + 10
};

const print_u64_with_base = fn(num: u64, base: u64, align: u64) { 'func_block
    if num == 0 {
        put_char(DIGIT0);
        break 'func_block;
    };

    let factor = 1;

    if align > 0 {
        while _iters < cast align  factor = factor * base;
    } else {
        while factor <= num        factor = factor * base;
    };

    while factor >= base {
        factor = factor / base;
        let digit = num / factor;
        num = num - digit * factor;

        put_char(DIGIT0 + (cast digit : u8));
    };
};

const print_u64 = fn(num: u64) { 'func_block
    if num == 0 {
        put_char(DIGIT0);
        break 'func_block;
    };

    let factor = 1;
    while factor <= num  factor = factor * 10;

    while factor >= 10 {
        factor = factor / 10;
        let digit = num / factor;
        num = num - digit * factor;

        put_char(DIGIT0 + (cast digit : u8));
    };
};
