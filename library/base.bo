library "intrinsics.bo";

const true = 1 > (0 : u8);
const false = 1 < (0 : u8);

const assert = i_assert;

const print = fn(string: [] u8) {
    i_stdout_write(string);
    i_stdout_flush();
};

const alloc.(T) = fn(count: usize) -> [] T {
    let buf = #0;
    buf.ptr = cast i_alloc(count * sizeof T);
    buf.len = count;
    buf
};

const dealloc.(T) = fn(buf: [] T) {
    let temp = #0;
    temp.ptr = cast buf.ptr;
    temp.len = buf.len * sizeof T;
    i_dealloc(temp);
};

const fill.(T) = fn(buf: [] T, value: T) {
    for buf { *_it = value; };
};

const slice_to_end.(T) = fn(buf: [] T, start: usize) -> [] T {
    slice.(T)(buf, start, buf.len)
};

const slice.(T) = fn(buf: [] T, start: usize, end: usize) -> [] T {
    assert(start < end);
    assert(end <= buf.len);
    let new = #uninit;
    new.ptr = buf.ptr + start;
    new.len = end - start;
    new
};

const count_matches.(T) = fn(buf: [] T, predicate: fn(T) -> bool) -> usize {
    let count = 0;
    for buf  if predicate(*_it)  count = count + 1;
    count
};

const CHAR_0_ASCII_CODE = 48 : u8;

// TEMPORARY until not operator is done a gain
const not = fn(v: bool) -> bool  if v false else true;

const cmp_strings = fn(a: []r u8, b: []r u8) -> bool { 'function
    if a.len != b.len  break 'function false;

    for 'loop c in a {
        if *c != *(b.ptr + _iters)  break 'loop false;
    } else true
};

const put_char = fn(c: u8) {
    let buf = #0;
    buf.ptr = &c;
    buf.len = 1;
    i_stdout_write(buf);
};

const take_until = fn(string: &rw []r u8, c: u8) -> []r u8 {
    let new = #uninit;
    // Why no typing error if you remove the dereference in (*string)???
    new.ptr = (*string).ptr;
    new.len = 0;

    while 'loop (*string).len > 0 {
        advance(string);

        if *(*string).ptr == c  break 'loop;
        new.len = new.len + 1;
    };

    new
};

const take_char = fn(string: &rw []r u8) -> u8 {
    let c = *(*string).ptr;
    advance(string);
    c
};

const advance_by = fn(string: &rw []r u8, by: usize) {
    assert((*string).len >= by);
    (*string).ptr = (*string).ptr + by;
    (*string).len = (*string).len - by;
};

const advance = fn(string: &rw []r u8) {
    if (*string).len > 0 {
        (*string).ptr = (*string).ptr + 1;
        (*string).len = (*string).len - 1;
    };
};

const empty = fn(string: &r []r u8) -> bool   (*string).len == 0;

const take_u64_with_base = fn(string: &rw []r u8, base: u64) -> u64 {
    let number = 0;
    while (*string).len > 0 {
        let c = *(*string).ptr;
        if not(is_digit(c))  break;
        number = number * base + (cast (c - CHAR_0_ASCII_CODE) : u64);
        advance(string);
    };
    number
};

const take_u64 = fn(string: &rw []r u8) -> u64 {
    let number = 0;
    while (*string).len > 0 {
        let c = *(*string).ptr;
        if not(is_digit(c))  break;
        number = number * 10 + (cast (c - CHAR_0_ASCII_CODE) : u64);
        advance(string);
    };
    number
};

const skip_num = fn(string: &rw []r u8) -> []r u8 {
    let new = #uninit;
    new.ptr = (*string).ptr;
    new.len = 0;

    while 'loop (*string).len > 0 {
        advance(string);
        if not(is_digit(*(*string).ptr))  break 'loop;
        new.len = new.len + 1;
    };

    new
};


const take_word = fn(string: &rw []r u8) -> []r u8 {
    let length = 0;
    let start = (*string).ptr;
    while (*string).len > 0 {
        if not(is_alpha(*(*string).ptr)) break;
        length = length + 1;
        advance(string);
    };

    let buf = #0;
    buf.len = length;
    buf.ptr = start;
    buf
};

const take_whitespace = fn(string: &rw []r u8) {
    while (*string).len > 0 {
        if not(is_whitespace(*(*string).ptr)) break;
        advance(string);
    };
};

const SPACE = *" ".ptr;
const NEW_LINE = *"\n".ptr;
const TAB = *"\t".ptr;
const CARRIAGE_RETURN = *"\r".ptr;
const LOWER_A = *"a".ptr;
const LOWER_Z = *"z".ptr;
const UPPER_A = *"A".ptr;
const UPPER_Z = *"Z".ptr;

const is_alpha = fn(c: u8) -> bool {
    (c >= LOWER_A && c <= LOWER_Z) || (c >= UPPER_A && c <= UPPER_Z)
};

const is_whitespace = fn(c: u8) -> bool {
    c == SPACE || c == NEW_LINE || c == TAB || c == CARRIAGE_RETURN
};

const is_digit = fn(c: u8) -> bool {
    c >= CHAR_0_ASCII_CODE && c < CHAR_0_ASCII_CODE + 10
};

const print_u64 = fn(num: u64) { 'func_block
    if num == 0 {
        put_char(CHAR_0_ASCII_CODE);
        break 'func_block;
    };

    let factor = 1;
    while factor <= num  factor = factor * 10;

    while factor >= 10 {
        factor = factor / 10;
        let digit = num / factor;
        num = num - digit * factor;

        put_char(CHAR_0_ASCII_CODE + (cast digit : u8));
    };
};
