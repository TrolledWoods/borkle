#no_base:

library "windows.bo";
library "iter.bo";
library "vec.bo";

const true = 1 > (0 : u8);
const false = 1 < (0 : u8);

const min.(T) = fn(a: T, b: T) -> T  if a < b  a else b;
const max.(T) = fn(a: T, b: T) -> T  if a > b  a else b;

const assert_eq.(T) = fn(a: T, b: T) {
    if a != b {
        print("Assert failed, % == %", a, b);
        abort();
    };
};

const assert = fn(condition: bool) {
    if !condition {
        put_string("Assert failed\n");
        abort();
    };
};

const abort = fn() {
    4 / 0 : u8;
};

const array_ptr   .(N, T) = fn(array: &[N] T) ->   &T    cast array;
const array_to_buf.(N, T) = fn(array: &[N] T) -> [] T    cast array;

const filled_array.(N, T) = fn(fill_with: T) -> [N] T {
    let arr = #uninit : [N] T;
    for &arr { *v = fill_with; };
    arr
};

const copy_buf.(T) = fn(to: &T, from: [] T) {
    copy(to, from.ptr, from.len);
};

const copy.(T) = fn(to: &T, from: &T, size: usize) {
    if from < to {
        while i < size {
            *(to + (size - i - 1)) = *(from + (size - i - 1));
        };
    } else {
        while i < size {
            *(to + i) = *(from + i);
        };
    };
};

const copy_nonoverlapping.(T) = fn(to: &T, from: &T, size: usize) {
    while i < size {
        *(to + i) = *(from + i);
    };
};

const alloc_copy.(T) = fn(original: [] T) -> [] T {
    let buf = alloc(original.len);
    copy_nonoverlapping(buf.ptr, original.ptr, original.len);
    buf
};

const alloc.(T) = fn(count: usize) -> [] T {
    if count > 0 {
        let buf = #0;
        buf.ptr = cast VirtualAlloc(#0, count * sizeof T, MEM_COMMIT, PAGE_READWRITE);
        buf.len = count;
        buf
    } else {
        #0
    }
};

const is_null.(T) = fn(pointer: &T) -> bool  pointer == #0 : &T;

const dealloc.(T) = fn(buf: [] T) {
    if buf.len > 0 {
        VirtualFree(cast buf.ptr, buf.len * sizeof T, MEM_DECOMMIT);
    };
};

const fill.(T) = fn(buf: [] T, value: T) {
    for &buf { *v = value; };
};

const arr_one.(T) = fn(v: &T) -> &[1] T {
    cast v
};

const buf_one.(T) = fn(v: &T) -> [] T {
    cast arr_one(v)
};

const slice_cmp.(T) = fn(a: [] T, b: [] T) -> bool { 'function
    if a.len != b.len  break 'function false;

    while i < a.len {
        if *(a.ptr + i) != *(b.ptr + i)  break 'function false;
    };

    true
};

const slice_to_end.(T) = fn(buf: [] T, start: usize) -> [] T {
    slice.(T)(buf, start, buf.len)
};

const slice.(T) = fn(buf: [] T, start: usize, end: usize) -> [] T {
    assert(start < end);
    assert(end <= buf.len);
    let new = #uninit;
    new.ptr = buf.ptr + start;
    new.len = end - start;
    new
};

const count_matches.(T) = fn(buf: [] T, predicate: fn(&T) -> bool) -> usize {
    let count = 0;
    for &buf  if predicate(v)  count = count + 1;
    count
};

const count_ones.(T) = fn(number: T) -> usize {
    let bit = 1;
    let num_bits = 0;
    while i < (8 * sizeof T) && bit <= number {
        if (number & bit) > 0  num_bits = num_bits + 1;
        bit = bit << 1;
    };
    num_bits
};

const NEGATIVE_SIGN = *"-".ptr : u8;
const LETTER_A = *"A".ptr : u8;
const DIGIT0 = *"0".ptr : u8;

const cmp_strings = fn(a: [] u8, b: [] u8) -> bool { 'function
    if a.len != b.len  break 'function false;

    for a {
        if v != *(b.ptr + i)  break false;
    } else true
};

const put_string = fn(c: [] u8) {
    let handle = GetStdHandle(STD_OUTPUT_HANDLE);
    if handle == #0 : &_                abort();
    if is_invalid_handle_value(handle)  abort();
    if c.ptr == #0 : &_                 abort();
    let result = WriteConsole(handle, c.ptr, cast c.len, &0, #0);
    if result != 1  ExitProcess(GetLastError());
};

const put_char = fn(c: u8) {
    let handle = GetStdHandle(STD_OUTPUT_HANDLE);
    WriteConsole(handle, &c, 1, &0, #0);
};

const take_char = fn(string: &[] u8) -> u8 {
    let c = *string.ptr;
    advance(string);
    c
};

const advance_by = fn(string: &[] u8, by: usize) {
    assert(string.len >= by);
    string.ptr = string.ptr + by;
    string.len = string.len - by;
};

const advance_rev = fn(string: &[] u8) {
    if string.len > 0 {
        string.len = string.len - 1;
    };
};

const advance = fn(string: &[] u8) {
    if string.len > 0 {
        string.ptr = string.ptr + 1;
        string.len = string.len - 1;
    };
};

const empty = fn(string: &[] u8) -> bool   string.len == 0;

const take_u64_with_base = fn(string: &[] u8, base: u64) -> u64 {
    let number = 0;
    while string.len > 0 {
        let c = *string.ptr;
        if !is_digit(c)  break;
        number = number * base + cast (c - DIGIT0) : u64;
        advance(string);
    };
    number
};

const take_u64 = fn(string: &[] u8) -> u64 {
    let number = 0;
    while string.len > 0 {
        let c = *string.ptr;
        if !is_digit(c)  break;
        number = number * 10 + cast (c - DIGIT0) : u64;
        advance(string);
    };
    number
};

const skip_num = fn(string: &[] u8) -> [] u8 {
    let new = #uninit;
    new.ptr = string.ptr;
    new.len = 0;

    while 'loop string.len > 0 {
        advance(string);
        if !is_digit(*string.ptr)  break 'loop;
        new.len = new.len + 1;
    };

    new
};


const take_word = fn(string: &[] u8) -> [] u8 {
    let length = 0;
    let start = string.ptr;
    while string.len > 0 {
        if !is_alpha(*string.ptr) break;
        length = length + 1;
        advance(string);
    };

    let buf = #0;
    buf.len = length;
    buf.ptr = start;
    buf
};

const trim_whitespace = fn(string: &[] u8) {
    take_whitespace(string);
    take_rev_whitespace(string);
};

const take_whitespace = fn(string: &[] u8) {
    while string.len > 0 {
        if !is_whitespace(*string.ptr) break;
        advance(string);
    };
};

const take_rev_whitespace = fn(string: &[] u8) {
    while string.len > 0 {
        if !is_whitespace(*(string.ptr + (string.len - 1))) break;
        advance_rev(string);
    };
};

const SPACE = *" ".ptr;
const DOUBLE_QUOTE = *"\"".ptr;
const NEW_LINE = *"\n".ptr;
const TAB = *"\t".ptr;
const CARRIAGE_RETURN = *"\r".ptr;
const LOWER_A = *"a".ptr;
const LOWER_Z = *"z".ptr;
const UPPER_A = *"A".ptr;
const UPPER_Z = *"Z".ptr;

const is_alpha = fn(c: u8) -> bool {
    (c >= LOWER_A && c <= LOWER_Z) || (c >= UPPER_A && c <= UPPER_Z)
};

const is_whitespace = fn(c: u8) -> bool {
    c == SPACE || c == NEW_LINE || c == TAB || c == CARRIAGE_RETURN
};

const is_digit = fn(c: u8) -> bool {
    c >= DIGIT0 && c < DIGIT0 + 10
};

const PERCENT = *"%".ptr;

type Writer.(T) = {
    state: &u8;
    write_buf : fn(&u8, [] T) -> usize;
    write_single : fn(&u8, T) -> usize;
    // If the writer discards the written things. Used for optimizations(you can skip calling write_buf or write_single altogether).
    discarding: bool;
};

// Writer that does nothing, except pretends everything went smoothly. This means you can read how many bytes were "written" without
// allocating a buffer to write into.
const count_writer.(T) = fn() -> Writer.(T) {
    let writer = #0;
    writer.discarding = true;
    writer.write_buf    = fn(_, buffer) buffer.len;
    writer.write_single = fn(_, _)      1;
    writer
};

// @HACK: Right now, it takes a reference to `buf`, and will modify it. Hence, if you write
// to a buffer, make sure to copy the buffer to a temporary variable first, before you
// reference it, so it doesn't remove your original buffer.
const buf_writer.(T) = fn(buf: &[] T) -> Writer.(T) {
    let writer = #0;
    writer.state = cast buf;
    writer.write_buf = fn(buf_ptr, from) {
        let buf = cast buf_ptr : &[] T;
        let writing = min(buf.len, from.len);

        copy_nonoverlapping(buf.ptr, from.ptr, writing);
        buf.len = buf.len - writing;
        buf.ptr = buf.ptr + writing;

        writing
    };
    writer.write_single = fn(buf_ptr, from) {
        let buf = cast buf_ptr : &[] T;
        if buf.len > 0 {
            *buf.ptr = from;
            buf.len = buf.len - 1;
            buf.ptr = buf.ptr + 1;
            1
        } else {
            0
        }
    };
    writer
};

const vec_writer.(T) = fn(vec: &Vec.(T)) -> Writer.(T) {
    let writer = #0;
    writer.state = cast vec;
    writer.write_buf = fn(vec_ptr, buffer) {
        let vec = cast vec_ptr : &Vec.(T);
        vec_push_buf(vec, buffer);
        buffer.len
    };
    writer.write_single = fn(vec_ptr, single) {
        let vec = cast vec_ptr : &Vec.(T);
        vec_push(vec, single);
        1
    };
    writer
};

const stderr_writer = fn() -> Writer.(u8) {
    let writer = #0;
    writer.write_buf = fn(_, buffer) {
        let written = 0;
        WriteConsole(GetStdHandle(STD_ERROR_HANDLE), buffer.ptr, cast buffer.len, &written, #0);
        cast written
    };
    writer.write_single = fn(_, c) {
        put_char(c);
        1
    };
    writer
};

const stdout_writer = fn() -> Writer.(u8) {
    let writer = #0;
    writer.write_buf = fn(_, buffer) {
        let written = 0;
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), buffer.ptr, cast buffer.len, &written, #0);
        cast written
    };
    writer.write_single = fn(_, c) {
        put_char(c);
        1
    };
    writer
};

const write_buf.(T) = fn(to: Writer.(T), buf: [] T) -> usize {
    to.write_buf(to.state, buf)
};

const write_single.(T) = fn(to: Writer.(T), value: T) -> usize {
    to.write_single(to.state, value)
};

type #alias: PadAlign = enum u8 {
    Left   = 0;
    Center = 1;
    Right  = 2;
};

const FMT_FLAGS_RAW = 1 : u8;

type Format.(T) = {
    value: T;
    pad: usize;
    pad_char: u8;
    pad_align: PadAlign;
    base: u8;
    flags: u8;
};

const write_i64 = fn(to: Writer.(u8), num: i64, base: u64) -> usize { 'func
    let written = 0;
    if num < 0 {
        written = written + write_single(to, NEGATIVE_SIGN);
        written = written + write_u64(to, cast -num, base);
    } else {
        written = written + write_u64(to, cast num, base);
    };

    written
};

const write_escaped_string = fn(to: Writer.(u8), string: [] u8) -> usize {
    let written = 0;

    written = written + write_single(to, DOUBLE_QUOTE);

    for string {
        if v == DOUBLE_QUOTE {
            written = written + write_buf(to, "\\\"");
        } else if v == CARRIAGE_RETURN {
            written = written + write_buf(to, "\\r");
        } else if v == TAB {
            written = written + write_buf(to, "\\t");
        } else if v == NEW_LINE {
            written = written + write_buf(to, "\\n");
        } else if v < 31 {
            written = written + write_buf(to, "\\x");
            written = written + write_u64(to, cast v, 10);
        } else {
            written = written + write_single(to, v);
        };
    };

    written = written + write_single(to, DOUBLE_QUOTE);

    written
};

const print_u64 = fn(num: u64, base: u64) -> usize {
    write_u64(stdout_writer(), num, base)
};

const write_u64 = fn(to: Writer.(u8), num: u64, base: u64) -> usize { 'func
    if num == 0 {
        break 'func write_single(to, DIGIT0);
    };

    let factor = 1;
    while factor <= num     factor = factor * base;

    let written = 0;
    while factor >= base {
        factor = factor / base;
        let digit = num / factor;
        num = num - digit * factor;

        if digit >= 10 {
            written = written + write_single(to, LETTER_A + (cast digit : u8 - 10));
        } else {
            written = written + write_single(to, DIGIT0 + (cast digit : u8));
        };
    };

    written
};

const write_fmt_no_padding.(T) = fn(to: Writer.(u8), fmt_val: Format.(T)) -> usize {
    let value = if #const: T is &_ {
        *fmt_val.value
    } else {
        fmt_val.value
    };

    if #const: typeof value is u8 || typeof value is u16 || typeof value is u32 || typeof value is u64 || typeof value is usize {
        let base = if fmt_val.base == 0 { 10 } else { fmt_val.base };
        write_u64(to, cast value, cast base)
    } else if #const: typeof value is i8 || typeof value is i16 || typeof value is i32 || typeof value is i64 || typeof value is isize {
        let base = if fmt_val.base == 0 { 10 } else { fmt_val.base };
        write_i64(to, cast value, cast base)
    } else if #const: typeof value is bool {
        if value == false {
            write_buf(to, "false")
        } else if value == true {
            write_buf(to, "true")
        } else {
            write_buf(to, "bool(")
            + write_u64(to, cast (bit_cast value : u8), 10)
            + write_buf(to, ")")
        }
    } else if #const: typeof value is [] u8 {
        if (fmt_val.flags & FMT_FLAGS_RAW) > 0 {
            write_buf(to, value)
        } else {
            write_escaped_string(to, value)
        }
    } else {
        assert(false);
        0
    }
};

const write_fmt.(T) = fn(to: Writer.(u8), val: Format.(T)) -> usize {
    // pad left doesn't need any pre-computation
    let written = 0;
    if val.pad != 0 && val.pad_align != .Left {
        let count = write_fmt_no_padding(count_writer(), val);
        if val.pad > count {
            let padding = if val.pad_align == .Right {
                val.pad - count
            } else {
                (val.pad - count) / 2
            };
            while i < padding {
                written = written + write_single(to, if val.pad_char == 0  SPACE else val.pad_char);
            };
        };
    };

    written = written + write_fmt_no_padding(to, val);

    if val.pad != 0 && val.pad > written {
        let remaining = val.pad - written;
        let pad_char = if val.pad_char == 0  SPACE else val.pad_char;
        while i < remaining {
            written = written + write_single(to, pad_char);
        };
    };

    written
};

const fmt.(T) = fn(val: T) -> Format {
    if #const: T is Format {
        val
    } else {
        let thing = #0;
        thing.value = val;
        thing
    }
};

const raw_text.(T) = fn(value: T) -> Format {
    let format = fmt(value);
    format.flags = format.flags | FMT_FLAGS_RAW;
    format
};

const pad_char.(T) = fn(value: T, pad_char: u8) -> Format {
    let format = fmt(value);
    format.pad_char = pad_char;
    format
};

const pad.(T) = fn(value: T, pad: usize, pad_align: PadAlign) -> Format {
    let format = fmt(value);
    format.pad = pad;
    format.pad_align = pad_align;
    format
};

const base.(T) = fn(value: T, base: u8) -> Format {
    let format = fmt(value);
    format.base = base;
    format
};

const write.(Args) = fn(writer: Writer.(u8), format_str: [] u8, #var_args: args: Args) -> usize {
    let splits = split(format_str, fn(v) v == PERCENT);

    let written = 0;
    let sub_str = "hi";
    for #const: args {
        assert(splits.next(&splits.state, &sub_str));
        written = written + write_buf(writer, sub_str);
        written = written + write_fmt(writer, fmt(v));
    };

    if splits.next(&splits.state, &sub_str)  written = written + write_buf(writer, sub_str);

    written
};

const sprint.(Args) = fn(format_str: [] u8, #var_args: args: Args) -> [] u8 {
    let count = write(count_writer(), format_str, .args = args);
    let buffer = alloc(count);
    write(buf_writer(&{ buffer }), format_str, .args = args);
    buffer
};

const print.(Args) = fn(format_str: [] u8, #var_args: args: Args) {
    write(stdout_writer(), format_str, .args = args);
};

const eprint.(Args) = fn(format_str: [] u8, #var_args: args: Args) {
    write(stderr_writer(), format_str, .args = args);
};
