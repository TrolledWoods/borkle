#no_base:

library "intrinsics.bo";
library "vec.bo";
library "iter.bo";

const true = 1 > (0 : u8);
const false = 1 < (0 : u8);

const min.(T) = fn(a: T, b: T) -> T  if a < b  a else b;
const max.(T) = fn(a: T, b: T) -> T  if a > b  a else b;

const assert = i_assert;

const array_ptr   .(N, T) = fn(array: &[N] T) ->   &T    cast array;
const array_to_buf.(N, T) = fn(array: &[N] T) -> [] T    cast array;

const get_line = fn() -> typeof Vec.(u8) {
    vec_from_iter(take_while(stdin(), fn(v) *v != NEW_LINE))
};

const filled_array.(N, T) = fn(fill_with: T) -> [N] T {
    let arr = #uninit : [N] T;
    for &arr { *v = fill_with; };
    arr
};

const copy.(T) = fn(to: &T, from: &T, size: usize) {
    i_copy(cast from, cast to, size * sizeof T);
};

const copy_nonoverlapping.(T) = fn(to: &T, from: &T, size: usize) {
    i_copy_nonoverlapping(cast from, cast to, size * sizeof T);
};

const alloc.(T) = fn(count: usize) -> [] T {
    let buf = #0;
    buf.ptr = cast i_alloc(count * sizeof T);
    buf.len = count;
    buf
};

const dealloc.(T) = fn(buf: [] T) {
    let temp = #0;
    temp.ptr = cast buf.ptr;
    temp.len = buf.len * sizeof T;
    i_dealloc(temp);
};

const fill.(T) = fn(buf: [] T, value: T) {
    for &buf { *v = value; };
};

const slice_cmp.(T) = fn(a: [] T, b: [] T) -> bool { 'function
    if a.len != b.len  break 'function false;

    while i < a.len {
        if *(a.ptr + i) != *(b.ptr + i)  break 'function false;
    };

    true
};

const slice_to_end.(T) = fn(buf: [] T, start: usize) -> [] T {
    slice.(T)(buf, start, buf.len)
};

const slice.(T) = fn(buf: [] T, start: usize, end: usize) -> [] T {
    assert(start < end);
    assert(end <= buf.len);
    let new = #uninit;
    new.ptr = buf.ptr + start;
    new.len = end - start;
    new
};

const count_matches.(T) = fn(buf: [] T, predicate: fn(&T) -> bool) -> usize {
    let count = 0;
    for &buf  if predicate(v)  count = count + 1;
    count
};

const count_ones.(T) = fn(number: T) -> usize {
    let bit = 1;
    let num_bits = 0;
    while i < (8 * sizeof T) && bit <= number {
        if (number & bit) > 0  num_bits = num_bits + 1;
        bit = bit << 1;
    };
    num_bits
};

const DIGIT0 = 48 : u8;

// TEMPORARY until not operator is done a gain
const not = fn(v: bool) -> bool  if v false else true;

const cmp_strings = fn(a: [] u8, b: [] u8) -> bool { 'function
    if a.len != b.len  break 'function false;

    for a {
        if v != *(b.ptr + i)  break false;
    } else true
};

const put_char = fn(c: u8) {
    let buf = #0;
    buf.ptr = &c;
    buf.len = 1;
    i_stdout_write(buf);
};

const take_char = fn(string: &[] u8) -> u8 {
    let c = *string.ptr;
    advance(string);
    c
};

const advance_by = fn(string: &[] u8, by: usize) {
    assert(string.len >= by);
    string.ptr = string.ptr + by;
    string.len = string.len - by;
};

const advance = fn(string: &[] u8) {
    if string.len > 0 {
        string.ptr = string.ptr + 1;
        string.len = string.len - 1;
    };
};

const empty = fn(string: &[] u8) -> bool   string.len == 0;

const take_u64_with_base = fn(string: &[] u8, base: u64) -> u64 {
    let number = 0;
    while string.len > 0 {
        let c = *string.ptr;
        if not(is_digit(c))  break;
        number = number * base + cast (c - DIGIT0) : u64;
        advance(string);
    };
    number
};

const take_u64 = fn(string: &[] u8) -> u64 {
    let number = 0;
    while string.len > 0 {
        let c = *string.ptr;
        if not(is_digit(c))  break;
        number = number * 10 + cast (c - DIGIT0) : u64;
        advance(string);
    };
    number
};

const skip_num = fn(string: &[] u8) -> [] u8 {
    let new = #uninit;
    new.ptr = string.ptr;
    new.len = 0;

    while 'loop string.len > 0 {
        advance(string);
        if not(is_digit(*string.ptr))  break 'loop;
        new.len = new.len + 1;
    };

    new
};


const take_word = fn(string: &[] u8) -> [] u8 {
    let length = 0;
    let start = string.ptr;
    while string.len > 0 {
        if not(
            is_alpha(
                *string.ptr
            )) break;
        length = length + 1;
        advance(string);
    };

    let buf = #0;
    buf.len = length;
    buf.ptr = start;
    buf
};

const take_whitespace = fn(string: &[] u8) {
    while string.len > 0 {
        if not(is_whitespace(*string.ptr)) break;
        advance(string);
    };
};

const SPACE = *" ".ptr;
const NEW_LINE = *"\n".ptr;
const TAB = *"\t".ptr;
const CARRIAGE_RETURN = *"\r".ptr;
const LOWER_A = *"a".ptr;
const LOWER_Z = *"z".ptr;
const UPPER_A = *"A".ptr;
const UPPER_Z = *"Z".ptr;

const is_alpha = fn(c: u8) -> bool {
    (c >= LOWER_A && c <= LOWER_Z) || (c >= UPPER_A && c <= UPPER_Z)
};

const is_whitespace = fn(c: u8) -> bool {
    c == SPACE || c == NEW_LINE || c == TAB || c == CARRIAGE_RETURN
};

const is_digit = fn(c: u8) -> bool {
    c >= DIGIT0 && c < DIGIT0 + 10
};

const PERCENT = *"%".ptr;

const Writer.(T) = #0 : {
    state: &u8;
    write_buf : fn(&u8, [] T) -> usize;
    write_single : fn(&u8, T) -> usize;
    // If the writer discards the written things. Used for optimizations(you can skip calling write_buf or write_single altogether).
    discarding: bool;
};

// Writer that does nothing, except pretends everything went smoothly. This means you can read how many bytes were "written" without
// allocating a buffer to write into.
const count_writer.(T) = fn() -> typeof Writer.(T) {
    let writer = #0;
    writer.discarding = true;
    writer.write_buf    = fn(_, buffer) buffer.len;
    writer.write_single = fn(_, _)      1;
    writer
};

const vec_writer.(T) = fn(vec: &typeof Vec.(T)) -> typeof Writer.(T) {
    let writer = #0;
    writer.state = cast vec;
    writer.write_buf = fn(vec_ptr, buffer) {
        let vec = cast vec_ptr : &typeof Vec.(T);
        vec_push_buf(vec, buffer);
        buffer.len
    };
    writer.write_single = fn(vec_ptr, single) {
        let vec = cast vec_ptr : &typeof Vec.(T);
        vec_push(vec, single);
        1
    };
    writer
};

const stdout_writer = fn() -> typeof Writer.(u8) {
    let writer = #0;
    writer.write_buf = fn(_, buffer) {
        i_stdout_write(buffer);
        buffer.len
    };
    writer.write_single = fn(_, c) {
        put_char(c);
        1
    };
    writer
};

const write_buf.(T) = fn(to: typeof Writer.(T), buf: [] T) -> usize {
    to.write_buf(to.state, buf)
};

const write_single.(T) = fn(to: typeof Writer.(T), value: T) -> usize {
    to.write_single(to.state, value)
};

const PAD_LEFT   = 0 : u8;
const PAD_CENTER = 1 : u8;
const PAD_RIGHT  = 2 : u8;

const Format.(T) = #0 : {
    value: T;
    pad: usize;
    pad_char: u8;
    pad_dir: u8;
    base: u8;
};

const write_u64 = fn(to: typeof Writer.(u8), num: u64, base: u64) -> usize { 'func
    if num == 0 {
        break 'func write_single(to, DIGIT0);
    };

    let factor = 1;

    while factor <= num     factor = factor * base;

    let written = 0;
    while factor >= base {
        factor = factor / base;
        let digit = num / factor;
        num = num - digit * factor;

        written = written + write_single(to, DIGIT0 + (cast digit : u8));
    };

    written
};

const write_fmt_no_padding.(T) = fn(to: typeof Writer.(u8), fmt_val: typeof Format.(T)) -> usize {
    let value = if #const: T is &_ {
        *fmt_val.value
    } else {
        fmt_val.value
    };

    if #const: typeof value is u8 || typeof value is u16 || typeof value is u32 || typeof value is u64 {
        let base = if fmt_val.base == 0 { 10 } else { fmt_val.base };
        write_u64(to, cast value, cast base)
    } else if #const: typeof value is typeof Vec.(u8) {
        write_buf(to, vec_as_buffer(&value))
    } else if #const: typeof value is [] u8 {
        write_buf(to, value)
    } else {
        assert(false);
        0
    }
};

const write_fmt.(T) = fn(to: typeof Writer.(u8), val: typeof Format.(T)) -> usize {
    // pad left doesn't need any pre-computation
    let written = 0;
    if val.pad != 0 && val.pad_dir != PAD_LEFT {
        let count = write_fmt_no_padding(count_writer(), val);
        if val.pad > count {
            let padding = if val.pad_dir == PAD_RIGHT {
                val.pad - count
            } else {
                (val.pad - count) / 2
            };
            while i < padding {
                written = written + write_single(to, val.pad_char);
            };
        };
    };

    written = written + write_fmt_no_padding(to, val);

    if val.pad != 0 && val.pad > written {
        let remaining = val.pad - written;
        let pad_char = if val.pad_char == 0  SPACE else val.pad_char;
        while i < remaining {
            written = written + write_single(to, pad_char);
        };
    };

    written
};

const fmt.(T) = fn(val: T) -> typeof Format {
    if #const:
    type T == type typeof Format.(u8)
    || type T == type typeof Format.(u16)
    || type T == type typeof Format.(u32)
    || type T == type typeof Format.(u64)
    || type T == type typeof Format.(type [] u8) {
        val
    } else {
        let thing = #0;
        thing.value = val;
        thing
    }
};

const pad.(T) = fn(value: T, pad: usize, pad_dir: u8, pad_char: u8) -> typeof Format {
    let format = fmt(value);
    format.pad = pad;
    format.pad_dir = pad_dir;
    format.pad_char = pad_char;
    format
};

const base.(T) = fn(value: T, base: u8) -> typeof Format {
    let format = fmt(value);
    format.base = base;
    format
};

const write.(Args) = fn(writer: typeof Writer.(u8), format_str: [] u8, #var_args: args: Args) -> usize {
    let splits = split(format_str, fn(v) v == PERCENT);

    let written = 0;
    let sub_str = #0;
    for #const: args {
        assert(splits.next(&splits.state, &sub_str));
        written = written + write_buf(writer, sub_str);
        written = written + write_fmt(writer, fmt(v));
    };

    if splits.next(&splits.state, &sub_str)  written = written + write_buf(writer, sub_str);

    written
};

const print.(Args) = fn(format_str: [] u8, #var_args: args: Args) {
    write(stdout_writer(), format_str, .args = args);
    i_stdout_flush();
};
