library "base.bo";
import "tests/main.bo";

const copy_with_predicate.(A, B, T) = fn(input: &[A] T, output: &[B] T, pred: fn(&T, &T) -> bool) {
    let output_ptr = cast &output : &T;

    let i = 0;
    for cast input : &T {
        if i >= B  break;

        if pred(_it, output_ptr + i) {
            *(output_ptr + i) = *_it;
        };
    };
};

const to_buffer.(T, N) = fn(input: &[N] T) -> [] T {
    let buf = #0;
    buf.ptr = cast input;
    buf.len = N;
    buf
};

const fold.(T, V) = fn(list: [] T, initial_value: V, folder: fn(V, &T) -> V) -> V {
    for list  initial_value = folder(initial_value, _it);

    initial_value
};

// This causes crash! Why?
//
// const copy.(A, T) = fn(input: &[A] typeof T, output: &[A] typeof T) {
//     copy_with_predicate.(_, _, #0)(input, output, fn(v0, v1) true);
// };

const apply.(T, R) = fn(input: T, func: fn(T) -> R) -> R {
    func(input)
};

const PrintVec3.(T) = fn(v: [3] T) {
    print("x: ");
    print_u64(cast v._0);
    print("y: ");
    print_u64(cast v._1);
    print("z: ");
    print_u64(cast v._2);
    print("\n");
};

#entry fn() -> u64 {
    let arr = [1, 2, 3] : [_] u8;
    fold(to_buffer(&arr), 0, fn(s, x) s + cast *x)
};


// This crashes for now (polymorphics being resolved at typing time)
//
// let stack_array = #0 : [
//     count_matches.(u8)("Hello ,,,, ,, , , ,", fn(v) *v == COMMA)
// ] u64;
