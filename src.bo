import "tests/main.bo";
library "vec.bo";
library "iter.bo";
library "timer.bo";

#entry fn() {
    let timer = start_timer();
    let thing = range(0, 1_000_000 : u64)->map(fn(x) x * 2)->collect_vec();
    defer vec_free(thing);
    print("collect vec time: % microseconds\n", timer->get_micros());

    let timer = start_timer();
    let vec = vec_new();
    (&vec)->reserve(1_000_000);
    (&vec)->extend(range(0, 1_000_000 : u64)->map(fn(x) x * 2));
    defer vec_free(vec);
    print("preallocated vec time: % microseconds\n", timer->get_micros());

    let timer = start_timer();
    range(0, 1_000_000 : u64)->map(fn(x) x * 2)->count();
    print("no vec time: % microseconds\n", timer->get_micros());
};

// IR emission improvements
//
// - Swapping variables using destructuring, for example, (x, y) = (y, x), is broken with the current system, this should be fixed!
// - Arrays need a `Value` as well.

// Removing the `type` on Chain in library\iter causes a compiler lockup

// Roadmap for full(and decent) x64 support:
//
// - Handle floats
// - Support multiple calling conventions; for one, we can do one that's better than the windows one, and, linux/mac probably don't use the same one anyway, so we need this logic
// - Generalize moving memory from one place to another(basically memcpy intrinsic)
// - Defer to typechecking improvement to allow for implicit casts again -> `cfg` tag to do some form of conditional compilation; will not be like C preprocessor directives though, since we both run at compile-time and at runtime, so that isn't good enough

// TODO:
// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
// - "This is imported twice" error should show where it was imported (even if implicit)
// - `!` operator should work properly for booleans


// -- For being able to build this again once I forget
// nasm output.asm -fwin64
// cl output.obj /link OneCore.lib /entry:function_2 /subsystem:console
