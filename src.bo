library "windows.bo";

create_exe_native("target/output.exe", fn #target .Native: () {

    let normal_string = fix_c(c"This is a c string!\n");
    put_string(normal_string);

    print("The c string is %\n", c"message");

    let number = 42 : u32;
    let dynamic_title = sprint("This is a dynamic title, with the number %!\0", number);
    defer dealloc(dynamic_title);

    // ruin_c asserts that the string you pass ends in a null terminator.
    MessageBox(#0, pack &a"Hello!\0"._0, ruin_c(dynamic_title), 0);

    for a"abc" {
        print("% is %\n", i, fmt_char(v));
    };
});

// IR emission improvements
//
// - Arrays need a `Value` as well.

// Roadmap for full(and decent) x64 support:
//
// - Handle floats(in calling convention)
// - Support xmm registers in register allocator, it gets more confusing however since the registers are no longer general purpose at that point.
// - Support multiple calling conventions; for one, we can do one that's better than the windows one, and, linux/mac probably don't use the same one anyway, so we need this logic
// - Generalize moving memory from one place to another(basically memcpy intrinsic)
// - Defer to typechecking improvement to allow for implicit casts again -> `cfg` tag to do some form of conditional compilation; will not be like C preprocessor directives though, since we both run at compile-time and at runtime, so that isn't good enough

// TODO:

// - I want to separate a `TypeSystem` that is being inferred, and a type system that is already completely inferred, because the way you treat them is very different, and the one currently in inferrence
//   may need more information, such as the reasoning and so one. So, make it more SOA, so that it's possible to remove data that's no longer required, and to make things more cache friendly, and,
//   we want to figure out a method to say that we know more about something. ( probably `#[repr(C)]` and transmutes/pointer casts!!!!! Hooray :D. Seems bad, but it actually lets me insert all the asserts
//   into one place in debug mode, so I think it would actually make the code much clearer )

// - Monomorphisation doesn't work 100% of the time in constant expressions, specifically, it doesn't work when the function you monomorphised itself calls another polymorphic function, (probably only applies to those that depend on its generic parameters).

// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
// - "This is imported twice" error should show where it was imported (even if implicit)
