#no_base:


const WriteConsole = fn(console_handle: &u8, buffer: &u8, num_chars: u32, written: &u32, _: &u8) -> i32  extern "WriteConsoleA";
const GetStdHandle = fn(handle: u32) -> &u8  extern "GetStdHandle";
const STD_OUTPUT_HANDLE = cast (-11 : i32) : u32; // cast (-11 : i32) : u32; //  4294967285 : u32;

const is_invalid_handle_value = fn(handle: &u8) -> bool {
    bit_cast handle : isize == -1
};


#entry fn() {

    let written = 0;
    let message = "Hello, world!\n";
    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), message.ptr, cast message.len, &written, #0);

};

// Roadmap for full(and decent) x64 support:
//
// * - Handle large arguments
// - Handle floats
// * - Actually handle getting passed arguments, 
// - fill the return slot.
// - Support multiple calling conventions; for one, we can do one that's better than the windows one, and, linux/mac probably don't use the same one anyway, so we need this logic
// - Generalize moving memory from one place to another(basically memcpy intrinsic)
// - Proper register allocator
// - `cfg` tag to do some form of conditional compilation; will not be like C preprocessor directives though, since we both run at compile-time and at runtime, so that isn't good enough

// TODO:
// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
// - "This is imported twice" error should show where it was imported (even if implicit)
// - `!` operator should work properly for booleans


// -- For being able to build this again once I forget
// nasm output.asm -fwin64
// cl output.obj /link OneCore.lib /entry:function_2 /subsystem:windows
