import "tests/main.bo";
library "iter.bo";
library "intrinsics.bo";
library "vec.bo";

const PERCENT = *"%".ptr;

const Writer = #0 : {
    state: &u8;
    write_buf : fn(&u8, [] u8) -> usize;
    write_single : fn(&u8, u8) -> usize;
};

const vec_writer = fn(vec: &typeof Vec.(u8)) -> typeof Writer {
    let writer = #0;
    writer.state = cast vec;
    writer.write_buf = fn(vec_ptr, buffer) {
        let vec = cast vec_ptr : &typeof Vec.(u8);
        vec_push_buf(vec, buffer);
        buffer.len
    };
    writer.write_single = fn(vec_ptr, single) {
        let vec = cast vec_ptr : &typeof Vec.(u8);
        vec_push(vec, single);
        1
    };
    writer
};

const stdout_writer = fn() -> typeof Writer {
    let writer = #0;
    writer.write_buf = fn(_, buffer) {
        i_stdout_write(buffer);
        buffer.len
    };
    writer.write_single = fn(_, c) {
        put_char(c);
        1
    };
    writer
};

const write_buf = fn(to: &typeof Writer, buf: [] u8) -> usize {
    to.write_buf(to.state, buf)
};

const write_single = fn(to: &typeof Writer, value: u8) -> usize {
    to.write_single(to.state, value)
};

const Format.(T) = #0 : {
    value: T;
    pad: usize;
    pad_char: u8;
    base: u8;
};

const write_u64 = fn(to: typeof Writer, num: u64, base: u64) -> usize { 'func
    if num == 0 {
        break 'func write_single(&to, DIGIT0);
    };

    let factor = 1;

    while factor <= num     factor = factor * base;

    let written = 0;
    while factor >= base {
        factor = factor / base;
        let digit = num / factor;
        num = num - digit * factor;

        written = written + write_single(&to, DIGIT0 + (cast digit : u8));
    };

    written
};

const write_fmt.(T) = fn(to: typeof Writer, val: typeof Format.(T)) -> usize {
    let written = if #const: type T == u8 || type T == u16 || type T == u32 || type T == u64 {
        let base = if val.base == 0 { 10 } else { val.base };
        write_u64(to, cast val.value, cast base)
    } else if #const: type T == type typeof Vec.(u8) || type T == type typeof &Vec.(u8) {
        write_buf(&to, vec_as_buffer(&val.value))
    } else if #const: type T == type [] u8 {
        write_buf(&to, val.value)
    } else {
        // Cannot format this type of value
        assert(false);
        0
    };

    if val.pad != 0 && val.pad > written {
        let remaining = val.pad - written;
        let pad_char = if val.pad_char == 0  SPACE else val.pad_char;
        while i < remaining {
            written = written + write_single(&to, pad_char);
        };
    };

    written
};

const fmt.(T) = fn(val: T) -> typeof Format {
    if #const:
    type T == type typeof Format.(u8)
    || type T == type typeof Format.(u16)
    || type T == type typeof Format.(u32)
    || type T == type typeof Format.(u64)
    || type T == type typeof Format.(type [] u8) {
        val
    } else {
        let thing = #0;
        thing.value = val;
        thing
    }
};

const pad.(T) = fn(value: T, pad: usize) -> typeof Format {
    let format = fmt(value);
    format.pad = pad;
    format
};

const pad_char.(T) = fn(value: T, pad_char: u8) -> typeof Format {
    let format = fmt(value);
    format.pad_char = pad_char;
    format
};

const write.(Args) = fn(writer: typeof Writer, format_str: [] u8, args: Args) -> usize {
    let splits = split(format_str, fn(v) v == PERCENT);

    let written = 0;
    let sub_str = #0;
    for #const: args {
        assert(splits.next(&splits.state, &sub_str));
        written = written + write_buf(&writer, sub_str);
        written = written + write_fmt(writer, fmt(v));
    };

    if splits.next(&splits.state, &sub_str)  written = written + write_buf(&writer, sub_str);

    written
};

const printf.(Args) = fn(format_str: [] u8, args: Args) {
    write(stdout_writer(), format_str, args);
};

#entry fn() {
    let vec = vec_new();
    defer vec_free(vec);
    let writer = vec_writer(&vec);
    write(writer, "%, %, %!\n", (1 : u8, "hello", 3 : u16));
    printf("%\n", (vec,));

    // New
    printf("Hello %, the number is %\n", ("world", 42 : u32));

    // Old
    print("Hello ");
    print("world");
    print(", the number is ");
    print_u64(cast (42 : u32));
    print("\n");

};

// TODO:
// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
