library "iter.bo";
import "tests/main.bo";

type Complex = {
    real: f64;
    imag: f64;
};

const complex = fn(real: f64, imag: f64) -> Complex {
    let result = #uninit;
    result.real = real;
    result.imag = imag;
    result
};

const add_c = fn(a: Complex, b: Complex) -> Complex {
    let result = #uninit;
    result.real = a.real + b.real;
    result.imag = a.imag + b.imag;
    result
};

const square_c = fn(a: Complex) -> Complex {
    let result = #uninit;
    result.real = a.real * a.real - a.imag * a.imag;
    result.imag = 2.0 * a.real * a.imag;
    result
};

const magnitude_sqr = fn(a: Complex) -> f64 {
    a.real * a.real + a.imag * a.imag
};

#entry fn() {
    let y = 0.0 - 2.0 : f64;
    while y < 2.0 {
        let x = 0.0 - 2.0 : f64;
        while x < 2.0 {
            let z = complex(0.0, 0.0);
            let c = complex(x, y);
            let char = while i < 100 {
                z = add_c(square_c(z), c);
                if magnitude_sqr(z) >= 4.0  break *".".ptr;
            } else *"#".ptr;
            put_char(char);
            x = x + 0.025;
        };

        put_string("\n");

        y = y + 0.05;
    };
};

// IR emission improvements
//
// - Swapping variables using destructuring, for example, (x, y) = (y, x), is broken with the current system, this should be fixed!
// - Arrays need a `Value` as well.

// Roadmap for full(and decent) x64 support:
//
// - Handle floats
// - Support multiple calling conventions; for one, we can do one that's better than the windows one, and, linux/mac probably don't use the same one anyway, so we need this logic
// - Generalize moving memory from one place to another(basically memcpy intrinsic)
// - Defer to typechecking improvement to allow for implicit casts again -> `cfg` tag to do some form of conditional compilation; will not be like C preprocessor directives though, since we both run at compile-time and at runtime, so that isn't good enough

// TODO:

// - Monomorphisation doesn't work 100% of the time in constant expressions, specifically, it doesn't work when the function you monomorphised itself calls another polymorphic function, (probably only applies to those that depend on its generic parameters).

// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
// - "This is imported twice" error should show where it was imported (even if implicit)


// -- For being able to build this again once I forget
// nasm output.asm -fwin64
// cl output.obj /link OneCore.lib /entry:function_2 /subsystem:console
