#no_base:

const write_console = fn(buffer: &u8, console_handle: &u8, num_chars: u16, written: &u16, _: &u8) -> i32  extern "WriteConsoleA";





const message_box = fn(_: i32, message: &u8, title: &u8, _: i32) -> i32  extern "MessageBoxA";

const write_things.(Args) = fn(#var_args: messages: Args) -> [] u8 {
    for #const: messages {
        message_box(0, v._1.ptr, v._0.ptr, 0);
    };

    "This string is returned\0"
};

#entry fn() {

    let temp = fn(v: &u8) {};

    let x = 0 : u8;
    temp(#0);

    if x == 99  {
        message_box(0, "Worked!\0".ptr, "Worked!\0".ptr, 0);
    };



    let return_string = write_things(["A\0", "B\0"], ["Cdifjijdf\0", "difjodifjoahsudhuirv\0"], ["JLKdjlkfsdf\0", "oiedsfijoasdfijo\0", "Ignored\0"]);

    message_box(0, return_string.ptr, return_string.ptr, 0);


    // inner_func(&0, 0, ["Hi\0", "Hi2\0", "Hi3\0"]);
};

// Roadmap for full(and decent) x64 support:
//
// * - Handle large arguments
// - Handle floats
// * - Actually handle getting passed arguments, 
// - fill the return slot.
// - Support multiple calling conventions; for one, we can do one that's better than the windows one, and, linux/mac probably don't use the same one anyway, so we need this logic
// - Generalize moving memory from one place to another(basically memcpy intrinsic)
// - Proper register allocator
// - `cfg` tag to do some form of conditional compilation; will not be like C preprocessor directives though, since we both run at compile-time and at runtime, so that isn't good enough

// TODO:
// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
// - "This is imported twice" error should show where it was imported (even if implicit)
// - `!` operator should work properly for booleans


// -- For being able to build this again once I forget
// nasm output.asm -fwin64
// cl output.obj /link OneCore.lib /entry:function_2 /subsystem:windows
