#no_base:

// library "windows.bo";

const generic.(T) = fn(var: T) -> T {
    // Sample
    let x = var;
    x
};

const non_generic.(T) = fn(var: T) {
    let x = var;
    generic(x);
};

const non_generic_u32 = non_generic.(u32);
const non_generic_u64 = non_generic.(u64);

const ExitProcess = fn(exit_code: u32) -> ()  extern "ExitProcess";

const call_back2 = fn(thing: u64) -> u32 {
    ExitProcess(cast thing);

    0
};

const is_invalid_handle_value = fn(handle: &u8) -> bool {
    bit_cast handle : isize == -1
};

const generic_func = generic.(u32); 

#entry fn() {
    generic(3 : u32);
    generic(3 : u64);
    non_generic_u32(3 : u32);
    non_generic_u64(3 : u64);

    test();

    let func_ptr = generic;
    func_ptr(99 : u32);

    call_back2(42 : u64);

    ExitProcess(0);
};

// Roadmap for full(and decent) x64 support:
//
// * - Handle large arguments
// - Handle floats
// * - Actually handle getting passed arguments, 
// * - fill the return slot.
// - Support multiple calling conventions; for one, we can do one that's better than the windows one, and, linux/mac probably don't use the same one anyway, so we need this logic
// - Generalize moving memory from one place to another(basically memcpy intrinsic)
// - Proper register allocator
// - `cfg` tag to do some form of conditional compilation; will not be like C preprocessor directives though, since we both run at compile-time and at runtime, so that isn't good enough

// TODO:
// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
// - "This is imported twice" error should show where it was imported (even if implicit)
// - `!` operator should work properly for booleans


// -- For being able to build this again once I forget
// nasm output.asm -fwin64
// cl output.obj /link OneCore.lib /entry:function_2 /subsystem:console

import "tests/main.bo";
// const test = fn() {
//     let x = 99 : u32;
// };

