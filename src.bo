library "iter.bo";
import "tests/main.bo";

type #alias: String = [] u8;

type EnumOne = enum [3] String {
    A = ["hello", "sir", "hello"];
    B = ["this", "is", "a"];
    C = ["this", "bean", "bag"];
};

#entry fn() {
    let a: EnumOne = .B;
    let b: EnumOne = .C;

    if slice_cmp((unpack a)._1, (unpack b)._1) == .Greater {
        print("Uh oh\n");
    };

    run_tests();
};

// IR emission improvements
//
// - Swapping variables using destructuring, for example, (x, y) = (y, x), is broken with the current system, this should be fixed!
// - Arrays need a `Value` as well.

// Roadmap for full(and decent) x64 support:
//
// - Handle floats(in calling convention)
// - Support xmm registers in register allocator, it gets more confusing however since the registers are no longer general purpose at that point.
// - Support multiple calling conventions; for one, we can do one that's better than the windows one, and, linux/mac probably don't use the same one anyway, so we need this logic
// - Generalize moving memory from one place to another(basically memcpy intrinsic)
// - Defer to typechecking improvement to allow for implicit casts again -> `cfg` tag to do some form of conditional compilation; will not be like C preprocessor directives though, since we both run at compile-time and at runtime, so that isn't good enough

// TODO:

// - Monomorphisation doesn't work 100% of the time in constant expressions, specifically, it doesn't work when the function you monomorphised itself calls another polymorphic function, (probably only applies to those that depend on its generic parameters).

// - Make [ptr + usize -> _] also infer to [ptr + usize -> ptr] (maybe similar for other operators too?)
// - "This is imported twice" error should show where it was imported (even if implicit)

// - Enum variants should have the type of the enum itself.

// -- For being able to build this again once I forget
// nasm output.asm -fwin64
// cl output.obj /link OneCore.lib /entry:function_2 /subsystem:console
