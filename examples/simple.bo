/*

# Design goals;

* Unambiguity;
    There should be no ambiguity as for what is going on.

* Consistancy;
    A lot of patterns should be kept throughout the language, to make
    sure that things are intuitive and kept simple.

* No dependency restriction
    Dependencies in the compiler are fine, but should still be kept to
    a somewhat minimal number; I don't want the compiler taking ages
    to compile, and also I want to know what my dependencies are doing.


# Constistancy patterns;

* All/most operations should be designed as a keyword or identifier first,
  and the data afterwards. The only exception will be very common operations,
  such as math operators for example.

* Constants should be camel case.

* Local variables should be snake case.

* [name] : [type] always means that name is of some type.

* [name] = [value] (or [name]: [type] = [value]) always means that the name is set to the value.

*/

const Answer : i64 = 42;

const MyConstant = {
    // Binary operators are like in most languages.
    let x = 3 + 2;

    // Except, chained binary operators require parenthesees.
    let y = (x * 2) + 5;

    // Unary operators apply to the literal or parenthesis to
    // their right, but nothing more. This is visually indicated
    // by not having a space between a unary operator and it's
    // operand.
    let unary1 = -3 + 2;
    let unary2 = -(3 + 2);

    // There are a few exceptions to this however. That is
    // member operators, '.' and '->'. That's simply because
    // functions and types with members practically never have
    // operations occur on them before being chained, so it makes
    // sense to have higher priority. It's also visually indicated
    // because there are no spaces between '.', '->' and their
    // arguments. The only potentially confusing thing is that
    // unary operators and these special binary operators both
    // don't use spaces, but that's trivial to learn, and not
    // hard to see at all.
    let dist_squared = (-pos.x * -pos.x) + (pos.y * pos.y);
    
    // That's just because in most cases it makes no sense to apply
    // unary operators just before doing a member access.
    
    // You can call functions
    let result = Function(Answer, 13);

    // You can put the first argument of a function on the left hand side
    // by using the arrow operator '->'. Just neat syntactic sugar.
    let result2 = Answer->Function(13);
};
